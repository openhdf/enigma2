Enigma2 BoxInfo Class
---------------------

The BoxInfo class is a new system and box information data management 
class.  The configuration data comes from a system generated data file 
called "enigma.info".

The "enigma.info" file is generated by the build system and contains 
exactly the same data as provided by kernel and "boxbranding" modules. 
The new file is located as "/usr/lib/enigma.info" and is easier to 
locate than the kernel module whose location varies depending on the 
kernel in use.  The contents of the "enigma.info" have a checksum that 
is verified when Enigma2 starts to check the validity / consistency of 
the file.  This file has been made text to simplify its use and has 
*NOT* been done to encourage user editing.  PLEASE DO NOT EDIT THIS 
FILE!  It is created automatically by the build system and maintained 
by system updates.

The BoxInfo class offers six main methods:

getItemsList()

	This method returns a sorted list of all the BoxInfo class variables.

getProcList()

	This method returns a sorted list of all the BoxInfo class variables 
	that are obtained from the system information file.

getEnigmaList()

	This method returns a sorted list of all the BoxInfo class variables 
	that are obtained from the system information override file.

getItem(item, default)

	This method returns the current value of a BoxInfo item.  If the 
	item is not found then the default value is returned.  If no default 
	is provided then a default on None is assumed.

setItem(item, value, immutable)

	This method sets or updates the current value of a BoxInfo item.  The 
	immutable argument is an optional Boolean value that specifies in this 
	item is to be made immutable.  Immutable items can only be created 
	and read.  It can not be updated or deleted.  It is a write once, read 
	many type variable.  NOTE: All the system configuration data items 
	are immutable!  By default all system information variables are 
	mutable by default.  Any mutable variable can be made immutable by 
	setting its value with the immutable argument set to True.

deleteItem(item)

	This method deletes an item from the system.  NOTE: No immutable 
	variables can be deleted!


Enigma Information File
=======================

The Enigma information file is a text file that is created by the image 
build process.  The file is stored in "/usr/lib/enigma.info".  The file is 
a simple text file with lines of "item=value" lines.  The file also contains 
an checksum entry that ensures the file is correct and is as generated.  This 
file must *NOT* be edited.  It is required to remain intact to ensure the 
correct data is available to ensure that Enigma2 can start and operate 
correctly.

To allow for system development an override facility has been built into the 
system.  If the developer / user creates a file "enigma.conf" in the same 
location as "enigma.info" then the values defined in "enigma.info" can be 
overridden for development and testing purposes.  This override file does not 
need to exist and should only exist to allow for specific purposes required 
during code development.  Creating override values that are not correct for 
the hardware in use can make Enigma2 not start or become unstable.

Another use for the "enigma.conf" file is to create new system information 
variables that can be prototyped and tested before being integrated into the 
build process.


Enigma2 Kernel Module
=====================

This module is a replacement for all existing hardware checks, it replaces 
boxbranding, enigma2 internal methods like getBoxType().  This feature is 
implemented via SystemInfo.  This is intended to be a single entry point 
for accessing and managing all hardware and system data.

This data is accessed and managed via the BoxInfo class within SystemInfo.py. 
Unlike the SystemInfo dictionary the data is contained and isolated within 
the SystemInfo module.  There is no need to export or share the dictionary 
across Enigma2 modules.

Enigma2 internal calls need enigma2 to be running first so can't be used 
outside of Enigma2 and boxbranding works if you import it so not a good 
solution for shell scripts and anything other than Python.


System Information Variables
============================
The first thing to note is that which ever mechanism, defined above, is 
used in an image to deliver the system information data the item variables 
should always remain consistent.  If a variable is used in "enigma.info" 
then that same item name *MUST* be the same and provide *EXACTLY* the same 
information in the kernel module.

The system variables defined here are based on OE-Alliance's sources but has 
some items added and some removed.  Some of the variable names are different 
from those defined in the OE-Alliance "boxbranding" code.  The following list 
provides mapping to the original "boxbranding" method calls as appropriate.

Here is the list of variables currently supported:

	BoxInfo variable    Boxbranding function
	----------------    --------------------
	"architecture"      "getImageArch()"
	"avjack"            "getHaveAVJACK()"
	"blindscanbinary"   "getBlindscanBin()"
	"brand"             "getBoxBrand()"  ("getMachineBrand() and "getBrandOEM()" in OE-Alliance's "boxbranding")
	"ci"                "getHaveCI()"
	"compiledate"
	"dboxlcd"           "getDBoxLCD()"
	"developername"     "getDeveloperName()"
	"displaybrand"      "getDisplayBrand()"
	"displaydistro"     "getDisplayDistro()"
	"displaymodel"      "getDisplayModel()"
	"displaytype"       "getDisplayType()"
	"distro"            "getImageDistro()"
	"dvi"               "getHaveDVI()"
	"feedsurl"          "getFeedsUrl()"
	"fhdskin"           "getFHDSkin()"
	"forcemode"         "getForceMode()"
	"fpu"               "getImageFPU()"
	"friendlyfamily"    "getFriendlyFamily()"
	"hdmi"              "getHaveHDMI()"
	"hdmifhdin"         "getHaveHDMIinFHD()"
	"hdmihdin"          "getHaveHDMIinHD()"
	"imagebuild"        "getImageBuild()"
	"imagedevbuild"     "getImageDevBuild()"
	"imagedir"          "getImageFolder()"
	"imagefs"           "getImageFileSystem()"
	"imagetype"         "getImageType()"
	"imageversion"      "getImageVersion()"
	"imglanguage"       "getIMGLanguage()
	"imgrevision"       "getIMGRevision()"
	"imgversion"        "getIMGVersion()"
	"kernel"            "getKernelVersion()"
	"kernelfile"        "getMachineKernelFile()"
	"mediaservice"      "getE2Service()"
	"middleflash"       "getHaveMiddleFlash()"
	"mkubifs"           "getMachineMKUBIFS()"
	"model"             "getBoxType()"  ("getMachineName()" and "getMachineMake()" in OE-Alliance's "boxbranding")
	"mtdbootfs"         "getMachineMtdBoot()"
	"mtdkernel"         "getMachineMtdKernel()"
	"mtdrootfs"         "getMachineMtdRoot()"
	"multilib"          "getHaveMultiLib()"
	"multitranscoding"  "getHaveMultiTranscoding()"  ("getHaveTranscoding2()" in OE-Alliance's "boxbranding")
	"oe"                "getOEVersion()"
	"platform"          "getMachineBuild()"
	"python"
	"rca"               "getHaveRCA()"
	"rcidnum"           "getRCIDNum()"
	"rcname"            "getRCName()"
	"rctype"            "getRCType()"
	"rootfile"          "getMachineRootFile()"
	"scart"             "getHaveSCART()"
	"smallflash"        "getHaveSmallFlash()"
	"socfamily"         "getSoCFamily()"
	"svideo"            "getHaveSVIDEO()"
	"transcoding"       "getHaveTranscoding()"  ("getHaveTranscoding1()" in OE-Alliance's "boxbranding")
	"ubinize"           "getMachineUBINIZE()"
	"vfdsymbol"         "getHaveVFDSymbol()"
	"wol"               "getHaveWOL()"  (Also "getHaveWWOL()" in OE-Alliance's "boxbranding" as we don't split Wake-on-LAN and Wake-on-WLAN)
	"yuv"               "getHaveYUV()"

	Boxbranding function         BoxInfo variable
	--------------------         ----------------
	"getBlindscanBin()"          "blindscanbinary"
	"getBoxBrand()"              "brand"
	"getBoxType()"               "model"
	"getBrandOEM()"              "brand" ????
	"getDBoxLCD()"               "dboxlcd"
	"getDeveloperName()"         "developername"
	"getDisplayBrand()"          "displaybrand"
	"getDisplayDistro()"         "displaydistro"
	"getDisplayModel()"          "displaymodel"
	"getDisplayType()"           "displaytype"
	"getE2Service()"             "mediaservice"
	"getFHDSkin()"               "fhdskin"
	"getFeedsUrl()"              "feedsurl"
	"getForceMode()"             "forcemode"
	"getFriendlyFamily()"        "friendlyfamily"
	"getHaveAVJACK()"            "avjack"
	"getHaveCI()"                "ci"
	"getHaveDVI()"               "dvi"
	"getHaveHDMI()"              "hdmi"
	"getHaveHDMIinFHD()"         "hdmifhdin"
	"getHaveHDMIinHD()"          "hdmihdin"
	"getHaveMiddleFlash()"       "middleflash"
	"getHaveMultiLib()"          "multilib"
	"getHaveMultiTranscoding()"  "multitranscoding"
	"getHaveRCA()"               "rca"
	"getHaveSCART()"             "scart"
	"getHaveSVIDEO()"            "svideo"
	"getHaveSmallFlash()"        "smallflash"
	"getHaveTranscoding()"       "transcoding"
	"getHaveTranscoding1()"      "transcoding1" ????
	"getHaveTranscoding2()"      "multitranscoding2" ????
	"getHaveVFDSymbol()"         "vfdsymbol"
	"getHaveWOL()"               "wol"
	"getHaveWWOL()"
	"getHaveYUV()"               "yuv"
	"getIMGLanguage()"           "imglanguage"
	"getIMGRevision()"           "imgrevision"
	"getIMGVersion()"            "imgversion"
	"getImageArch()"             "architecture"
	"getImageBuild()"            "imagebuild"
	"getImageDevBuild()"         "imagedevbuild"
	"getImageDistro()"           "distro"
	"getImageFPU()"              "fpu"
	"getImageFileSystem()"       "imagefs"
	"getImageFolder()"           "imagedir"
	"getImageType()"             "imagetype"
	"getImageVersion()"          "imageversion"
	"getKernelVersion()"         "kernel"
	"getMachineBrand()"          "brand" ????
	"getMachineBuild()"          "platform"
	"getMachineKernelFile()"     "kernelfile"
	"getMachineMKUBIFS()"        "mkubifs"
	"getMachineMake()"           "model" ????
	"getMachineMtdBoot()"        "mtdbootfs"
	"getMachineMtdKernel()"      "mtdkernel"
	"getMachineMtdRoot()"        "mtdrootfs"
	"getMachineName()"           "model" ????
	"getMachineRootFile()"       "rootfile"
	"getMachineUBINIZE()"        "ubinize"
	"getOEVersion()"             "oe"
	"getRCIDNum()"               "rcidnum"
	"getRCName()"                "rcname"
	"getRCType()"                "rctype"
	"getSoCFamily()"             "socfamily"

* Replacement for getMachineProcModel is getBoxProc in StbHardware.py
* Replacement for OE-Alliance's boxbranding getDriverDate is getDriverInstalledDate in About.py (Components)
* Replacement for OE-Alliance's boxbranding getHaveMiniTV is LCDMiniTV in SystemInfo.py
* We don't have anything for OE-A's boxbranding getHaveSCARTYUV and we manage it via if conditions in VideoHardware.py

Time to explain each one and give examples:

architecture:

	BoxInfo.getItem("architecture")

		This variable defines the main architecture of the image.

		Useful when we want to know what kind of ipk files we can install 
		on a receiver via opkg or what type of binary files we could run.

	Example: cortexa15hf-neon-vfpv4

avjack:

	BoxInfo.getItem("avjack")

		This variable defines if a receiver has AV Jack output.

	Example: False

blindscanbinary:

	BoxInfo.getItem("blindscanbinary")

		This variable defines the blindscan binary file name.

		We use this for blindscan tools.

	Example: blindscan

brand:

	BoxInfo.getItem("brand")

		This variable defines the receiver brand or the meta name in OE sources.

		Real brand could be a different thing in real life, also not all the 
		times it's the brand name but sometimes it's the meta name so it's 
		related to OE sources.

	Example: airdigital

ci:

	BoxInfo.getItem("ci")

		This variable defines if a receiver has DVB Common Interface slot.

	Example: True

compiledate:

	BoxInfo.getItem("compiledate")

		This variable defines the compile date of the enigma.ko file.

	Example: 20210524

dboxlcd:

	BoxInfo.getItem("dboxlcd")

		This variable defines if a receiver supports eDBoxLCD enigma2 feature.

	Example: True

developername:

	BoxInfo.getItem("developername")

		This variable defines who compiled the image which could be a real developer 
		or just a certified compiler, some image compilers add/remove things and with 
		this variable we know which one has what packages.

	Example: persianpros

displaybrand:

	BoxInfo.getItem("displaybrand")

		This variable defines the receiver real brand in real life.

		Real brand is what printed on the receiver.

	Example: Zgemma

displaydistro:

	BoxInfo.getItem("displaydistro")

		This variable shows the friendly distro name.

		Mostly we use this for information pages.

	Example: Open Vision

displaymodel:

	BoxInfo.getItem("displaymodel")

		This variable defines the receiver real model in real life.

		Real model is what printed on the receiver.

	Example: H9T

displaytype:

	BoxInfo.getItem("displaytype")

		This variable defines the front display type of a receiver.

	Example: colorlcd400 (for h9 this is empty and I just wrote an example)

distro:

	BoxInfo.getItem("distro")

		This variable defines the image distro.

		Mostly we use this for multiboot tools.

	Example: openvision

dvi:

	BoxInfo.getItem("dvi")

		This variable defines if a receiver has DVI output.

	Example: False

feedsurl:

	BoxInfo.getItem("feedsurl")

		This variable defines the main feed URL for opkg.

	Example: https://feeds.openenigma.org

fhdskin:

	BoxInfo.getItem("fhdskin")

		This variable defines if a receiver supports Full HD skins.

	Example: True

forcemode:

	BoxInfo.getItem("forcemode")

		This variable defines the force mode of the zip file.

		Some receivers won't flash without enabling the force mode.

		Mostly we use this for backup tools.

	Example: no

fpu:

	BoxInfo.getItem("fpu")

		This variable defines the fpu type which is the float type of 
		the architecure and it's CPU dependent.

	Example: hard

friendlyfamily:

	BoxInfo.getItem("friendlyfamily")

		This variable defines other names that may be out there instead of the machine name.

		By default MACHINE is what we use but users may know their boxes
		with similar/different names. This results in confusing users as
		they may not know which image is compatible for their boxes to install.
		Friendly Family shows which boxes could use a common image.

	Example: zgemmah9s zgemmah9t zgemmah92s zgemmah92h zgemmah9splus

hdmi:

	BoxInfo.getItem("hdmi")

		This variable defines if a receiver has HDMI output.

	Example: True

hdmifhdin:

	BoxInfo.getItem("hdmifhdin")

		This variable defines if a receiver has HDMI-In (Full HD) input.

	Example: False

hdmihdin:

	BoxInfo.getItem("hdmihdin")

		This variable defines if a receiver has HDMI-In input.

	Example: False

imagebuild:

	BoxInfo.getItem("imagebuild")

		This variable defines the image build.

		Mostly we use this for backup tools and compatibility with other images.

	Example: master

imagedevbuild:

	BoxInfo.getItem("imagedevbuild")

		This variable defines the image developer build.

		Mostly we use this for backup tools and compatibility with other images.

	Example: new

imagedir:

	BoxInfo.getItem("imagedir")

		This variable defines the image directory for a receiver and how the 
		structure of the zip file should be.

		Mostly we use this for backup tools.

	Example: h9

imagefs:

	BoxInfo.getItem("imagefs")

		This variable defines the image filesystem for a receiver which can boot.

		Mostly we use this for backup tools.

	Example: ubi (sometimes there's a space at the beginning of this variable which should be avoided)

imagetype:

	BoxInfo.getItem("imagetype")

		This variable defines the image type.

		Mostly we use this for backup tools and compatibility with other images.

	Example: release

imageversion:

	BoxInfo.getItem("imageversion")

		This variable defines the image version.

		Mostly we use this for backup tools and compatibility with other images.

	Example: develop

imglanguage:

	BoxInfo.getItem("imglanguage")

		This variable defines the language set which could be english, multilanguage 
		or extralanguage (which has all) depending on the flash size.

		multilanguage has ar, de, es, it, ru and tr locales.

	Example: extralanguage

imgrevision:

	BoxInfo.getItem("imgrevision")

		This variable defines the image revision which changes after a batch of changes.

	Example: r396

imgversion:

	BoxInfo.getItem("imgversion")

		This variable defines the main image version which only changes when 
		GCC changes or when other important packages like python get updated.

	Example: 10.3

informations:

	BoxInfo.getItem("informations")

		This variable includes all enigma proc informations in one file.

	Example: All above examples in one file

kernel:

	BoxInfo.getItem("kernel")

		This variable defines the kernel version.

		Let us know what version of the kernel a receiver has so what features 
		are compatible.

	Example: 4.4.35

kernelfile:

	BoxInfo.getItem("kernelfile")

		This variable defines the kernel file name of an image.

		Mostly we use this for backup tools.

	Example: uImage

mediaservice:

	BoxInfo.getItem("mediaservice")

		This variable defines the enigma2 media service.

	Example: enigma2-plugin-systemplugins-servicehisilicon

middleflash:

	BoxInfo.getItem("middleflash")

		This variable defines the flash size and if it's equal to 128MB or 
		less but more than 64MB.

		Even some receivers with 128MB flashes can not flash or boot images 
		more than 96MB because of a limit in their CFE.

		We use this to compile compatible images for middle flash receivers.

	Example: False

mkubifs:

	BoxInfo.getItem("mkubifs")

		This variable defines the mkubifs command parameters.

		Mostly we use this for backup tools when want to repack the image.

	Example: -m 2048 -e 126976 -c 8192

model:

	BoxInfo.getItem("model")

		This variable defines the receiver model in OE sources.

		Real model could be a different thing in real life and this is 
		only what kernel defconfig shows as hostname.

	Example: h9

mtdbootfs:

	BoxInfo.getItem("mtdbootfs")

		This variable defines the boot filesystem mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mmcblk0p4 (for h9 this is empty and I just wrote an example)

mtdkernel:

	BoxInfo.getItem("mtdkernel")

		This variable defines the kernel mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mtd6

mtdrootfs:

	BoxInfo.getItem("mtdrootfs")

		This variable defines the root filesystem mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mtd7

multilib:

	BoxInfo.getItem("multilib")

		This variable defines the multilib situation.

		It can only be True if an image has aarch64 architecture and lib64 
		is available in the root directory.

	Example: False

multitranscoding:

	BoxInfo.getItem("multitranscoding")

		This variable defines if a receiver supports multi transcoding feature.

	Example: True

oe:

	BoxInfo.getItem("oe")

		This variable defines the OE branch.

		If it's anything other than "master" means it's fixed on a specific branch 
		like pyro and there will be no more updates from main OE and requires only 
		monthly maintenance to keep it up-to-date with other sources.

	Example: master

platform:

	BoxInfo.getItem("platform")

		This variable defines the receiver platform in OE sources.

		This is not a real thing, it's what developers call a family of 
		similar hardwares.  Instead of checking models one by one we 
		could assign something to a family and reduce the checks.
		If a model does not belong to a family the platform will be 
		same as model so model and platform are equal in some receivers.

	Example: zgemmahisi3798mv200

python:

	BoxInfo.getItem("python")

		This variable defines the python exact version.

	Example: 2.7.18

rca:

	BoxInfo.getItem("rca")

		This variable defines if a receiver has RCA output.

	Example: False

rcidnum:

	BoxInfo.getItem("rcidnum")

		This variable defines the remote control ID number.

		In remote control XML files we have a line like <rc id="2"> which 
		define what ID number could be used.

	Example: 2

rcname:

	BoxInfo.getItem("rcname")

		This variable defines the remote control name which we use for XML and 
		PNG files.

	Example: zgemma6

rctype:

	BoxInfo.getItem("rctype")

		This variable defines the remote control type.

	Example: 28

rootfile:

	BoxInfo.getItem("rootfile")

		This variable defines the root file name of an image.

		Mostly we use this for backup/multiboot tools.

	Example: rootfs.ubi

scart:

	BoxInfo.getItem("scart")

		This variable defines if a receiver has SCART output.

	Example: False

smallflash:

	BoxInfo.getItem("smallflash")

		This variable defines the flash size and if it's equal to 64MB 
		or less than that.

		We use this to compile compatible images for small flash receivers.

	Example: False

socfamily:

	BoxInfo.getItem("socfamily")

		This variable defines the SoC type.

		Some settings could be applied per SoC as they're CPU dependent.

	Example: hisi3798mv200

svideo:

	BoxInfo.getItem("svideo")

		This variable defines if a receiver has S-Video output.

	Example: False

transcoding:

	BoxInfo.getItem("transcoding")

		This variable defines if a receiver supports transcoding feature.

	Example: False

ubinize:

	BoxInfo.getItem("ubinize")

		This variable defines the ubinize command parameters.

		Mostly we use this for backup tools when want to repack the image.

	Example: -m 2048 -p 128KiB

vfdsymbol:

	BoxInfo.getItem("vfdsymbol")

		This variable defines if a receiver supports VFD symbol feature.

		It also depends on the display type.

	Example: False

wol:

	BoxInfo.getItem("wol")

		This variable defines if a receiver supports Wake-on-LAN/WLAN feature.

	Example: True

yuv:

	BoxInfo.getItem("yuv")

		This variable defines if a receiver has YUV output.

	Example: False

(Remember: All "enigma.info" data is immutable.)
